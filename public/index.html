<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Peace Missile Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <style> body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; } canvas { display: block; } </style>
</head>
<body>
<div id="phaser-game"></div>
<script type="text/javascript">
    const tg = window.Telegram.WebApp;
    const currentUser = (tg.initDataUnsafe && tg.initDataUnsafe.user) ? tg.initDataUnsafe.user : null;
    let db; // Firebase veritabanı nesnesi

    try {
        const firebaseConfig = {
            apiKey: "AIzaSyBtOkm8dpjVXLzAXCEB5sL_Awqq4HEeemc",
            authDomain: "peacemissile-game.firebaseapp.com",
            projectId: "peacemissile-game",
            storageBucket: "peacemissile-game.firebasestorage.app",
            messagingSenderId: "641906716058",
            appId: "1:641906716058:web:1376e93994fab29f049e23"
        };
        if (typeof firebase !== 'undefined') {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
        } else {
            console.error("Firebase SDK yüklenmedi. Firebase betiklerinin bu betikten önce dahil edildiğinden emin olun.");
        }
    } catch (e) {
        console.error("Firebase başlatma başarısız oldu:", e);
    }

    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
            this.score = 0;
            this.gameIsOver = false;
            this.gameTime = 0;
            this.maxBuildingHealth = 3; 
            this.buildingsDestroyed = 0;
            this.totalBuildings = 0;
            this.healthBar = null; 

            this.referenceWidth = 1080; // Görselin referans genişliği
            this.referenceHeight = 1920; // Görselin referans yüksekliği
        }

        preload() {
            const urlParams = new URLSearchParams(window.location.search);
            this.selectedSide = urlParams.get('side') || 'israel';
            const bgKey = this.selectedSide === 'iran' ? 'iran_bg' : 'israel_bg';
            const bgUrl = `https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/${bgKey}.jpg`;
            this.load.image('background', bgUrl);
            this.load.image('rocket', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/rocket.png');
            this.load.image('explosion', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/explosion.gif');
            this.load.image('destroyed_building', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/destroyed_building.png'); 
        }

        create() {
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            // Arka planı ekran boyutuna göre ayarla
            let bg = this.add.image(gameWidth / 2, gameHeight / 2, 'background');
            bg.setDisplaySize(gameWidth, gameHeight);

            this.buildings = this.physics.add.staticGroup();
            this.destroyedBuildingSprites = this.add.group(); 
            
            const buildingsData = [];

            // Bina koordinatları ve boyutları (referans çözünürlüğe göre oranlı)
            // Y pozisyonları, binanın en üst pikselinden (veya çatısından) itibaren.
            // Height ise bu üst noktadan aşağıya doğru kutunun yüksekliği.
            if (this.selectedSide === 'israel') {
                buildingsData.push({ 
                    x: (550 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 450, // Binanın tabanından kaç piksel yukarıda başlıyor (referans resimde)
                    width: (400 / this.referenceWidth) * gameWidth, 
                    height: 300 // Çarpışma kutusu yüksekliği (referans resimde)
                });
                buildingsData.push({ 
                    x: (750 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 550, 
                    width: (300 / this.referenceWidth) * gameWidth, 
                    height: 350 
                });
                buildingsData.push({ 
                    x: (950 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 400, 
                    width: (200 / this.referenceWidth) * gameWidth, 
                    height: 250 
                });
            } else { // iran
                buildingsData.push({ 
                    x: (325 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 400, 
                    width: (550 / this.referenceWidth) * gameWidth, 
                    height: 300 
                });
                buildingsData.push({ 
                    x: (825 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 350, 
                    width: (350 / this.referenceWidth) * gameWidth, 
                    height: 250 
                });
            }

            this.totalBuildings = buildingsData.length;

            buildingsData.forEach((data) => {
                // Y koordinatını ekranın altından yOffsetFromBottom kadar yukarıya ayarla
                const yPos = gameHeight - (data.yOffsetFromBottom / this.referenceHeight) * gameHeight;
                const buildingHeight = (data.height / this.referenceHeight) * gameHeight;

                const buildingBody = this.buildings.create(data.x, yPos, null)
                    .setSize(data.width, buildingHeight)
                    .setOrigin(0.5, 0) // Üst ortaya hizala
                    .setVisible(false) 
                    .refreshBody();
                
                buildingBody.buildingHealth = this.maxBuildingHealth;
                buildingBody.totalHealth = this.maxBuildingHealth; 
                buildingBody.visualX = data.x; 
                buildingBody.visualY = yPos + (buildingHeight * 0.5); // Kraterin binanın orta seviyesine denk gelmesi için
                buildingBody.visualWidth = data.width; 
                buildingBody.visualHeight = buildingHeight; 
            });

            this.scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#fff', stroke: '#000', strokeThickness: 4 });
            this.healthBar = this.add.graphics();
            this.updateHealthBar(); 

            this.rockets = this.physics.add.group();
            this.physics.add.collider(this.rockets, this.buildings, this.hitBuilding, null, this);
            
            this.time.addEvent({ delay: 1500, callback: this.spawnRocket, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 1000, callback: this.increaseGameTime, callbackScope: this, loop: true });
        }

        updateHealthBar() {
            this.healthBar.clear();
            const gameWidth = this.cameras.main.width;
            const healthBarWidth = 200;
            const healthBarHeight = 30;
            const healthBarX = gameWidth - healthBarWidth - 16;
            const healthBarY = 16;

            let totalCurrentHealth = 0;
            this.buildings.children.each(b => {
                totalCurrentHealth += b.buildingHealth;
            });
            const totalMaxHealth = this.totalBuildings * this.maxBuildingHealth;
            const healthRatio = totalCurrentHealth / totalMaxHealth;

            this.healthBar.fillStyle(0x000000, 0.7); 
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            this.healthBar.fillStyle(0x00FF00); 
            if (healthRatio < 0.5) {
                this.healthBar.fillStyle(0xFFFF00); 
            }
            if (healthRatio < 0.25) {
                this.healthBar.fillStyle(0xFF0000); 
            }
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth * healthRatio, healthBarHeight);

            this.healthBar.lineStyle(2, 0xFFFFFF); 
            this.healthBar.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        }

        increaseGameTime() {
            this.gameTime++;
        }

        spawnRocket() {
            if (this.gameIsOver) return;

            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            let startX, startY, velocityX, velocityY, angle;
            let spawnType = Phaser.Math.Between(0, 100); 

            let baseSpeed = 150 + (this.gameTime * 2);
            let maxSpeed = 400 + (this.gameTime * 5);
            if (baseSpeed > 600) baseSpeed = 600;
            if (maxSpeed > 800) maxSpeed = 800;

            let buildingDamageBonus = this.buildingsDestroyed * 50; 
            baseSpeed += buildingDamageBonus;
            maxSpeed += buildingDamageBonus;

            // Yıkılmamış aktif binalardan rastgele birini hedefle
            const activeBuildings = this.buildings.children.entries.filter(b => b.body.enable);
            let targetBuilding = null;
            if (activeBuildings.length > 0) {
                targetBuilding = Phaser.Utils.Array.GetRandom(activeBuildings);
            }
            
            let targetX, targetY;
            if (targetBuilding) {
                // Roket, binanın çarpışma kutusunun üst yarısına veya çatısına doğru yönelsin
                // targetBuilding.y = çarpışma kutusunun üst kenarının Y koordinatı
                targetX = targetBuilding.x + Phaser.Math.Between(-targetBuilding.body.width / 4, targetBuilding.body.width / 4);
                targetY = targetBuilding.y + Phaser.Math.Between(0, targetBuilding.body.height / 3); // Binanın en üst 1/3'lük kısmını hedefle
            } else {
                // Hedef bina kalmadıysa, ekranın alt ortasını hedefle
                targetX = gameWidth / 2;
                targetY = gameHeight * 0.8;
            }


            if (this.gameTime < 10 || spawnType < 70) {
                // Yukarıdan aşağıya inen roket
                startX = Phaser.Math.Between(40, gameWidth - 40);
                startY = -100;
                
                const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                velocityX = Math.cos(angleToTarget) * speed;
                velocityY = Math.sin(angleToTarget) * speed;
                angle = Phaser.Math.RadToDeg(angleToTarget) + 90; 
            } else {
                // Yanlardan, kavisli gelen roketler
                let side = Phaser.Math.Between(0, 1) === 0 ? 'left' : 'right';

                if (side === 'left') {
                    startX = -100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7); 
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                } else { // 'right'
                    startX = gameWidth + 100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7);
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                }
            }

            const rocket = this.rockets.create(startX, startY, "rocket");
            rocket.setAngle(angle);
            rocket.setVelocity(velocityX, velocityY);
            rocket.setInteractive({ useHandCursor: true });
            rocket.on("pointerdown", () => this.destroyRocket(rocket));

            rocket.setCollideWorldBounds(false);
            rocket.body.onWorldBounds = true;
            this.physics.world.on('worldbounds', (body) => {
                if (body.gameObject === rocket && !this.gameIsOver) {
                    rocket.destroy();
                }
            }, this);
        }

        destroyRocket(rocket) {
            if (!rocket.active || this.gameIsOver) return;

            this.score += 10;
            this.scoreText.setText("Score: " + this.score);

            const explosion = this.add.image(rocket.x, rocket.y, "explosion").setScale(0.5);
            this.time.delayedCall(150, () => explosion.destroy());
            rocket.destroy();
        }

        hitBuilding(rocket, building) {
            if (!rocket.active || !building.body.enable || this.gameIsOver) return;

            building.buildingHealth--; 
            
            window.Telegram && window.Telegram.WebApp.HapticFeedback.notificationOccurred("error");

            const explosion = this.add.image(rocket.x, rocket.y + 20, "explosion").setScale(1.2).setTint(0xFF0000);
            this.time.delayedCall(300, () => explosion.destroy());
            this.cameras.main.shake(200, 0.02);

            rocket.destroy(); 

            if (building.buildingHealth <= 0) {
                this.buildingsDestroyed++;
                building.body.enable = false; 
                building.setVisible(false); 

                const destroyedSprite = this.add.image(building.visualX, building.visualY, 'destroyed_building');
                destroyedSprite.setOrigin(0.5, 0.5); 
                
                const scaleFactor = Math.min(building.visualWidth / destroyedSprite.width, building.visualHeight / destroyedSprite.height) * 0.7; 
                destroyedSprite.setScale(scaleFactor); 
                this.destroyedBuildingSprites.add(destroyedSprite);

                const finalExplosion = this.add.image(building.visualX, building.visualY, "explosion").setScale(2).setTint(0x800000);
                this.time.delayedCall(500, () => finalExplosion.destroy());
            }

            this.updateHealthBar(); 

            if (this.buildingsDestroyed >= this.totalBuildings) {
                this.gameOver();
            }
        }

        gameOver() {
            if (this.gameIsOver) return;
            this.gameIsOver = true;
            this.physics.pause();

            this.rockets.children.each(rocket => rocket.destroy());
            
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth, gameHeight, 0, 0.7);
            this.add.text(gameWidth / 2, gameHeight / 2, "OYUN BİTTİ\nSon Skor: " + this.score, { fontSize: "48px", fill: "#ff0000", align: "center" }).setOrigin(0.5);
            
            saveScore(this.score);

            window.Telegram && window.Telegram.WebApp && this.time.delayedCall(4000, () => window.Telegram.WebApp.close());
        }
    }

    function saveScore(score) {
        if (!db) {
            console.error("Firebase Firestore başlatılmadı. Skor kaydedilemiyor.");
            return;
        }
        if (!currentUser || !currentUser.id) {
            console.warn("Telegram kullanıcı verileri mevcut değil. Skor belirli bir kullanıcıya kaydedilmeyecek.");
            return;
        }

        const userDocRef = db.collection('users').doc(String(currentUser.id));
        userDocRef.update({
            score: firebase.firestore.FieldValue.increment(score),
            username: currentUser.username || currentUser.first_name || `User${currentUser.id}`
        }).catch(err => {
            if (err.code === 'not-found') {
                userDocRef.set({ score: score, username: currentUser.username || currentUser.first_name || `User${currentUser.id}` });
            } else { console.error("Firebase Hatası:", err); }
        });
    }

    const config = { type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, physics: { default: 'arcade', arcade: { gravity: { y: 0 } } }, scene: GameScene };
    try { const game = new Phaser.Game(config); } catch (e) { document.body.innerHTML = `<h1 style="color:red;">HATA: ${e.message}</h1>`; }
</script>
</body>
</html>