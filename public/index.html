<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Peace Missile Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <style> body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; } canvas { display: block; } </style>
</head>
<body>
<div id="phaser-game"></div>
<script type="text/javascript">
    const tg = window.Telegram.WebApp;
    const currentUser = (tg.initDataUnsafe && tg.initDataUnsafe.user) ? tg.initDataUnsafe.user : null;
    let db; // Firebase veritabanı nesnesi

    try {
        const firebaseConfig = {
            apiKey: "AIzaSyBtOkm8dpjVXLzAXCEB5sL_Awqq4HEeemc",
            authDomain: "peacemissile-game.firebaseapp.com",
            projectId: "peacemissile-game",
            storageBucket: "peacemissile-game.firebasestorage.app",
            messagingSenderId: "641906716058",
            appId: "1:641906716058:web:1376e93994fab29f049e23"
        };
        if (typeof firebase !== 'undefined') {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
        } else {
            console.error("Firebase SDK yüklenmedi. Firebase betiklerinin bu betikten önce dahil edildiğinden emin olun.");
        }
    } catch (e) {
        console.error("Firebase başlatma başarısız oldu:", e);
    }

    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
            this.score = 0;
            this.initialHealth = 3; // Başlangıç sağlık değeri, artık genel değil
            this.gameIsOver = false;
            this.gameTime = 0; // Oyun süresini takip etmek için
            this.maxBuildingHealth = 3; // Her binanın başlangıç dayanıklılığı
            this.buildingsDestroyed = 0; // Yıkılan bina sayısı
            this.totalBuildings = 0; // Toplam bina sayısı
            this.healthBar = null; // Sağlık çubuğu için
        }

        preload() {
            const urlParams = new URLSearchParams(window.location.search);
            this.selectedSide = urlParams.get('side') || 'israel';
            const bgKey = this.selectedSide === 'iran' ? 'iran_bg' : 'israel_bg';
            const bgUrl = `https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/${bgKey}.jpg`;
            this.load.image('background', bgUrl);
            this.load.image('rocket', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/rocket.png');
            this.load.image('explosion', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/explosion.gif');
            // VARSAYIMSAL YIKIK BİNA GÖRSELİ - BURAYI KENDİ GÖRSEL URL'NİZLE DEĞİŞTİRİN
            this.load.image('destroyed_building', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/crater.png'); // Örnek olarak bir krater görseli kullandım
            // Eğer "intact" (sağlam) bina görselleriniz varsa, onları da burada yüklemelisiniz
            // Örneğin: this.load.image('israel_building_1', 'path/to/israel_building_1.png');
            // Şu anda binalar görünmez çarpışma kutuları ve arka plan resmi üzerindeki yerlerini temsil ediyor.
            // Bu nedenle, hasar efekti için sadece alpha (opaklık) ve sonra 'destroyed_building' kullanacağız.
        }

        create() {
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            let bg = this.add.image(gameWidth / 2, gameHeight / 2, 'background');
            bg.setDisplaySize(gameWidth, gameHeight);

            this.buildings = this.physics.add.staticGroup();
            this.buildingSprites = this.add.group(); // Bina görsellerini tutacak grup
            
            const buildingsData = [];

            if (this.selectedSide === 'israel') {
                buildingsData.push({ x: gameWidth * 0.25, y: gameHeight, width: gameWidth * 0.4, height: 180, visualOffsetX: 0, visualOffsetY: -90 });
                buildingsData.push({ x: gameWidth * 0.6, y: gameHeight, width: gameWidth * 0.3, height: 280, visualOffsetX: 0, visualOffsetY: -140 });
                buildingsData.push({ x: gameWidth * 0.85, y: gameHeight, width: gameWidth * 0.2, height: 220, visualOffsetX: 0, visualOffsetY: -110 });
            } else { // iran
                buildingsData.push({ x: gameWidth * 0.3, y: gameHeight, width: gameWidth * 0.5, height: 200, visualOffsetX: 0, visualOffsetY: -100 });
                buildingsData.push({ x: gameWidth * 0.8, y: gameHeight, width: gameWidth * 0.3, height: 170, visualOffsetX: 0, visualOffsetY: -85 });
            }

            this.totalBuildings = buildingsData.length;

            buildingsData.forEach((data, index) => {
                const buildingBody = this.buildings.create(data.x, data.y, null)
                    .setSize(data.width, data.height)
                    .setOrigin(0.5, 1)
                    .setVisible(false) // Çarpışma kutusu görünmez kalır
                    .refreshBody();
                
                buildingBody.buildingHealth = this.maxBuildingHealth; // Binanın kendi sağlığı
                buildingBody.totalHealth = this.maxBuildingHealth; // Toplam sağlık, alpha hesaplaması için
                buildingBody.initialX = data.x;
                buildingBody.initialY = data.y;

                // Bina görselini oluştur (arka plan üzerindeki binanın yerini temsil ediyor)
                // Burada gerçek bina görselleriniz olsaydı, onları yüklersiniz.
                // Örneğin: this.add.image(data.x, data.y + data.visualOffsetY, `israel_building_${index+1}`);
                // Şimdilik, sadece arka plan üzerindeki alanı temsil eden bir görselimiz yok,
                // bu yüzden hasarı opaklık ile göstereceğiz.
                // Eğer arka plan resimlerindeki binaların üzerine oturan ayrı görselleriniz olsaydı,
                // onları burada oluşturup 'buildingBody.sprite' olarak atardık.
                // Şimdilik, bu görsel temsil için buildingBody'nin kendisini kullanacağız.
                // Yıkıldığında 'destroyed_building' görseli eklenecek.
            });


            this.scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#fff', stroke: '#000', strokeThickness: 4 });
            // Genel sağlık çubuğu (tüm binaların toplam sağlığı)
            this.healthBar = this.add.graphics();
            this.updateHealthBar(); // İlk sağlık çubuğunu çiz

            this.rockets = this.physics.add.group();
            this.physics.add.collider(this.rockets, this.buildings, this.hitBuilding, null, this);
            
            this.time.addEvent({ delay: 1500, callback: this.spawnRocket, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 1000, callback: this.increaseGameTime, callbackScope: this, loop: true });
        }

        updateHealthBar() {
            this.healthBar.clear();
            const gameWidth = this.cameras.main.width;
            const healthBarWidth = 200;
            const healthBarHeight = 30;
            const healthBarX = gameWidth - healthBarWidth - 16;
            const healthBarY = 16;

            let totalCurrentHealth = 0;
            this.buildings.children.each(b => {
                totalCurrentHealth += b.buildingHealth;
            });
            const totalMaxHealth = this.totalBuildings * this.maxBuildingHealth;
            const healthRatio = totalCurrentHealth / totalMaxHealth;

            // Arka plan çubuğu
            this.healthBar.fillStyle(0x000000, 0.7); // Siyah, yarı saydam
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Sağlık çubuğu
            this.healthBar.fillStyle(0x00FF00); // Yeşil
            if (healthRatio < 0.5) {
                this.healthBar.fillStyle(0xFFFF00); // Sarı
            }
            if (healthRatio < 0.25) {
                this.healthBar.fillStyle(0xFF0000); // Kırmızı
            }
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth * healthRatio, healthBarHeight);

            this.healthBar.lineStyle(2, 0xFFFFFF); // Beyaz çerçeve
            this.healthBar.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Metin yerine görsel bir çubuk kullanıyoruz
        }

        increaseGameTime() {
            this.gameTime++;
        }

        spawnRocket() {
            if (this.gameIsOver) return;

            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            let startX, startY, velocityX, velocityY, angle;
            let spawnType = Phaser.Math.Between(0, 100);

            let baseSpeed = 150 + (this.gameTime * 2);
            let maxSpeed = 400 + (this.gameTime * 5);
            if (baseSpeed > 600) baseSpeed = 600;
            if (maxSpeed > 800) maxSpeed = 800;

            let buildingDamageBonus = this.buildingsDestroyed * 50;
            baseSpeed += buildingDamageBonus;
            maxSpeed += buildingDamageBonus;

            // Roketler hedefe doğru gitsin diye genel bir hedef belirleyelim (bina alanının ortası)
            const targetX = gameWidth / 2;
            const targetY = gameHeight * 0.8; // Binaların olduğu bölge

            if (this.gameTime < 10 || spawnType < 70) {
                // Yukarıdan aşağıya inen roket
                startX = Phaser.Math.Between(40, gameWidth - 40);
                startY = -100;
                
                // Hedefe doğru yönlü hız hesapla
                const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                velocityX = Math.cos(angleToTarget) * speed;
                velocityY = Math.sin(angleToTarget) * speed;
                angle = Phaser.Math.RadToDeg(angleToTarget) + 90; // Roket görselini doğru yöne çevir
            } else {
                // Yanlardan, kavisli gelen roketler
                let side = Phaser.Math.Between(0, 1) === 0 ? 'left' : 'right';

                if (side === 'left') {
                    startX = -100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7); // Orta yüksekliklerden
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                } else { // 'right'
                    startX = gameWidth + 100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7);
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                }
            }

            const rocket = this.rockets.create(startX, startY, "rocket");
            rocket.setAngle(angle);
            rocket.setVelocity(velocityX, velocityY);
            rocket.setInteractive({ useHandCursor: true });
            rocket.on("pointerdown", () => this.destroyRocket(rocket));

            rocket.setCollideWorldBounds(false);
            rocket.body.onWorldBounds = true;
            this.physics.world.on('worldbounds', (body) => {
                if (body.gameObject === rocket && !this.gameIsOver) {
                    rocket.destroy();
                }
            }, this);
        }

        destroyRocket(rocket) {
            if (!rocket.active || this.gameIsOver) return;

            this.score += 10;
            this.scoreText.setText("Score: " + this.score);

            const explosion = this.add.image(rocket.x, rocket.y, "explosion").setScale(0.5);
            this.time.delayedCall(150, () => explosion.destroy());
            rocket.destroy();
        }

        hitBuilding(rocket, building) {
            if (!rocket.active || !building.body.enable || this.gameIsOver) return;

            building.buildingHealth--; // Binanın sağlığını azalt
            
            window.Telegram && window.Telegram.WebApp.HapticFeedback.notificationOccurred("error");

            // Patlama efekti
            const explosion = this.add.image(rocket.x, rocket.y + 20, "explosion").setScale(1.2).setTint(0xFF0000);
            this.time.delayedCall(300, () => explosion.destroy());
            this.cameras.main.shake(200, 0.02);

            rocket.destroy(); // Roketi imha et

            // Bina hasarını görselleştir (opaklık ve yıkık efekti)
            const healthRatio = building.buildingHealth / building.totalHealth;

            // Eğer bir bina görseliniz olsaydı, onun opaklığını ayarlardınız:
            // if (building.sprite) {
            //     building.sprite.setAlpha(0.2 + 0.8 * healthRatio); // 0.2'den 1'e kadar değişsin
            // }

            // Şimdilik bina görselimiz olmadığı için, sadece yıkım efektini yönetiyoruz.
            if (building.buildingHealth <= 0) {
                // Bina tamamen yıkıldı!
                this.buildingsDestroyed++;
                building.body.enable = false; // Çarpışmayı durdur
                building.setVisible(false); // Fiziksel kutuyu gizle

                // Yıkık bina görselini ekle
                const destroyedSprite = this.add.image(building.initialX, building.initialY - (building.body.height / 2), 'destroyed_building');
                // destroyedSprite.setOrigin(0.5, 0.5); // Görselin orijinini ayarlayın
                destroyedSprite.setScale(building.body.width / destroyedSprite.width * 0.8, building.body.height / destroyedSprite.height * 0.8); // Binanın boyutuna göre ölçekle (yaklaşık)
                this.buildingSprites.add(destroyedSprite); // Yeni görseli gruba ekle

                // Büyük bir patlama efekti
                const finalExplosion = this.add.image(building.initialX, building.initialY - (building.body.height / 2), "explosion").setScale(2).setTint(0x800000);
                this.time.delayedCall(500, () => finalExplosion.destroy());
            }

            this.updateHealthBar(); // Sağlık çubuğunu güncelle

            // Tüm binalar yıkıldı mı kontrol et
            if (this.buildingsDestroyed >= this.totalBuildings) {
                this.gameOver();
            }
        }

        gameOver() {
            if (this.gameIsOver) return;
            this.gameIsOver = true;
            this.physics.pause();

            this.rockets.children.each(rocket => rocket.destroy());
            
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth, gameHeight, 0, 0.7);
            this.add.text(gameWidth / 2, gameHeight / 2, "OYUN BİTTİ\nSon Skor: " + this.score, { fontSize: "48px", fill: "#ff0000", align: "center" }).setOrigin(0.5);
            
            saveScore(this.score);

            window.Telegram && window.Telegram.WebApp && this.time.delayedCall(4000, () => window.Telegram.WebApp.close());
        }
    }

    function saveScore(score) {
        if (!db) {
            console.error("Firebase Firestore başlatılmadı. Skor kaydedilemiyor.");
            return;
        }
        if (!currentUser || !currentUser.id) {
            console.warn("Telegram kullanıcı verileri mevcut değil. Skor belirli bir kullanıcıya kaydedilmeyecek.");
            return;
        }

        const userDocRef = db.collection('users').doc(String(currentUser.id));
        userDocRef.update({
            score: firebase.firestore.FieldValue.increment(score),
            username: currentUser.username || currentUser.first_name || `User${currentUser.id}`
        }).catch(err => {
            if (err.code === 'not-found') {
                userDocRef.set({ score: score, username: currentUser.username || currentUser.first_name || `User${currentUser.id}` });
            } else { console.error("Firebase Hatası:", err); }
        });
    }

    const config = { type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, physics: { default: 'arcade', arcade: { gravity: { y: 0 } } }, scene: GameScene };
    try { const game = new Phaser.Game(config); } catch (e) { document.body.innerHTML = `<h1 style="color:red;">HATA: ${e.message}</h1>`; }
</script>
</body>
</html>