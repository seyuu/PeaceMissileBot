<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Peace Missile Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style> 
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #000; 
            /* Mobil cihazlarda scrollbar veya boşluk oluşmaması için */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        } 
        canvas { 
            display: block; 
            /* Canvas'ın da ebeveynine göre tam boyut almasını sağlar */
            max-width: 100vw;
            max-height: 100vh;
        } 
    </style>
</head>
<body>
<div id="phaser-game"></div>
<script type="text/javascript">
    let tg;
    let currentUser;
    let db;
    let userWalletAddress = null; 

    class Preloader extends Phaser.Scene {
        constructor() {
            super({ key: 'Preloader' });
        }

        preload() {
            let progressBar = this.add.graphics();
            let progressBox = this.add.graphics();
            progressBox.fillStyle(0x222222, 0.8);
            progressBox.fillRect(this.cameras.main.centerX - 160, this.cameras.main.centerY - 25, 320, 50);

            let loadingText = this.make.text({
                x: this.cameras.main.centerX,
                y: this.cameras.main.centerY - 50,
                text: 'Loading...',
                style: {
                    font: '20px monospace',
                    fill: '#ffffff'
                }
            }).setOrigin(0.5, 0.5);

            let percentText = this.make.text({
                x: this.cameras.main.centerX,
                y: this.cameras.main.centerY,
                text: '0%',
                style: {
                    font: '18px monospace',
                    fill: '#ffffff'
                }
            }).setOrigin(0.5, 0.5);

            this.load.on('progress', function (value) {
                percentText.setText(parseInt(value * 100) + '%');
                progressBar.clear();
                progressBar.fillStyle(0xffffff, 1);
                progressBar.fillRect(this.cameras.main.centerX - 150, this.cameras.main.centerY - 15, 300 * value, 30);
            }, this);

            this.load.on('complete', function () {
                progressBar.destroy();
                progressBox.destroy();
                loadingText.destroy();
                percentText.destroy();
                this.scene.start('LobbyScene'); 
            }, this);

            this.load.image('lobby_bg', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/lobby_bg.jpg');
            this.load.image('play_button', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/play_button.png');
            this.load.image('score_icon', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/score_icon.png');
            this.load.image('coin_icon', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/coin_icon.png');
            
            this.load.image('rocket', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/rocket.png');
            this.load.image('explosion', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/explosion.gif');
            this.load.image('destroyed_building', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/destroyed_building.png'); 
            this.load.image('dove', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/dove.png'); 
            
            this.load.image('logo_part_1', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/logo_part_1.png');
            this.load.image('logo_part_2', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/logo_part_2.png');
            this.load.image('logo_part_3', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/logo_part_3.png');
            this.load.image('logo_part_4', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/logo_part_4.png');
            this.load.image('full_logo', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/logo.png'); 

            this.load.image('israel_bg', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/israel_bg.jpg');
            this.load.image('iran_bg', 'https://raw.githubusercontent.com/seyuu/PeaceMissileBot/main/public/assets/iran_bg.jpg');
        }

        create() {
            tg = window.Telegram.WebApp;
            currentUser = (tg.initDataUnsafe && tg.initDataUnsafe.user) ? tg.initDataUnsafe.user : null;
            tg.ready();
            tg.expand();
            console.log("Telegram WebApp Ready and Expanded.");
            console.log("Telegram initDataUnsafe:", tg.initDataUnsafe); // Debug için ekledim
            console.log("Current User:", currentUser); // Debug için ekledim

            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyBtOkm8dpjVXLzAXCEB5sL_Awqq4HEeemc",
                    authDomain: "peacemissile-game.firebaseapp.com",
                    projectId: "peacemissile-game",
                    storageBucket: "peacemissile-game.firebasestorage.app",
                    messagingSenderId: "641906716058",
                    appId: "1:641906716058:web:1376e93994fab29f049e23"
                };
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    console.log("Firebase başlatıldı.");
                } else {
                    console.error("Firebase SDK yüklenmedi. Firebase betiklerinin bu betikten önce dahil edildiğinden emin olun.");
                }
            } catch (e) {
                console.error("Firebase başlatma başarısız oldu:", e);
            }
        }
    }

    class LobbyScene extends Phaser.Scene {
        constructor() {
            super({ key: 'LobbyScene' });
        }

        create() {
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            this.add.image(gameWidth / 2, gameHeight / 2, 'lobby_bg').setDisplaySize(gameWidth, gameHeight);

            this.add.text(gameWidth / 2, gameHeight * 0.15, `Welcome, ${currentUser ? currentUser.first_name : 'Ambassador'}!`, { 
                fontSize: '38px', // Boyutu küçültüldü
                fill: '#fff', 
                stroke: '#000', 
                strokeThickness: 6 
            }).setOrigin(0.5);

            const playButton = this.add.image(gameWidth / 2, gameHeight * 0.8, 'play_button')
                .setScale(0.6) // Boyutu küçültüldü
                .setInteractive({ useHandCursor: true });

            playButton.on('pointerdown', () => {
                this.scene.start('GameScene');
            });

            this.add.image(gameWidth / 2 - 100, gameHeight * 0.35, 'score_icon').setScale(0.5); // Boyutu ve Y pozisyonu ayarlandı
            this.add.image(gameWidth / 2 - 100, gameHeight * 0.45, 'coin_icon').setScale(0.5); // Boyutu ve Y pozisyonu ayarlandı

            const highScoreText = this.add.text(gameWidth / 2 + 40, gameHeight * 0.35, `Loading...`, { fontSize: '24px', fill: '#fff' }).setOrigin(0.5); // Boyutu küçültüldü
            const coinsText = this.add.text(gameWidth / 2 + 40, gameHeight * 0.45, `Loading...`, { fontSize: '24px', fill: '#fff' }).setOrigin(0.5); // Boyutu küçültüldü

            if (currentUser && db) {
                const userDocRef = db.collection('users').doc(String(currentUser.id));
                userDocRef.get().then(doc => {
                    if (doc.exists) {
                        const data = doc.data();
                        highScoreText.setText(`${data.score || 0}`);
                        coinsText.setText(`${data.total_pmno_coins || 0}`);
                        console.log("Firebase user data loaded:", data); // Debug için ekledim
                    } else {
                        highScoreText.setText(`0`);
                        coinsText.setText(`0`);
                        console.log("Firebase user document does not exist, creating new default values.");
                        // Kullanıcı yoksa varsayılan değerlerle belge oluştur
                        userDocRef.set({
                            score: 0,
                            total_pmno_coins: 0,
                            total_score: 0,
                            username: currentUser.username || currentUser.first_name || `User${currentUser.id}`,
                            user_id: currentUser.id
                        }, { merge: true }).then(() => {
                            console.log("Initial user document created.");
                        }).catch(e => {
                            console.error("Error creating initial user document:", e);
                        });
                    }
                }).catch(err => {
                    console.error("Error fetching Firebase user data:", err);
                    highScoreText.setText(`Error`);
                    coinsText.setText(`Error`);
                });
            } else {
                highScoreText.setText(`N/A`);
                coinsText.setText(`N/A`);
                console.warn("Firebase or currentUser not available in LobbyScene. Scores cannot be loaded.");
            }
        }
    }

    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
            this.score = 0;
            this.gameIsOver = false;
            this.gameTime = 0;
            this.maxBuildingHealth = 3; 
            this.buildingsDestroyed = 0;
            this.totalBuildings = 0;
            this.healthBar = null; 
            
            this.referenceWidth = 1080; 
            this.referenceHeight = 1920; 

            this.logoPart1 = null;
            this.logoPart2 = null;
            this.logoPart3 = null;
            this.logoPart4 = null;
            this.fullLogo = null;
        }

        preload() {
            const urlParams = new URLSearchParams(window.location.search);
            this.selectedSide = urlParams.get('side') || 'israel';
        }

        create() {
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            const bgKey = this.selectedSide === 'iran' ? 'iran_bg' : 'israel_bg';
            let bg = this.add.image(gameWidth / 2, gameHeight / 2, bgKey);
            bg.setDisplaySize(gameWidth, gameHeight);

            this.buildings = this.physics.add.staticGroup();
            this.destroyedBuildingSprites = this.add.group(); 
            
            const buildingsData = [];

            if (this.selectedSide === 'israel') {
                buildingsData.push({ 
                    x: (550 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 450, 
                    width: (400 / this.referenceWidth) * gameWidth, 
                    height: 300 
                });
                buildingsData.push({ 
                    x: (750 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 550, 
                    width: (300 / this.referenceWidth) * gameWidth, 
                    height: 350 
                });
                buildingsData.push({ 
                    x: (950 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 400, 
                    width: (200 / this.referenceWidth) * gameWidth, 
                    height: 250 
                });
            } else { 
                buildingsData.push({ 
                    x: (325 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 400, 
                    width: (550 / this.referenceWidth) * gameWidth, 
                    height: 300 
                });
                buildingsData.push({ 
                    x: (825 / this.referenceWidth) * gameWidth, 
                    yOffsetFromBottom: 350, 
                    width: (350 / this.referenceWidth) * gameWidth, 
                    height: 250 
                });
            }

            this.totalBuildings = buildingsData.length;

            buildingsData.forEach((data) => {
                const yPos = gameHeight - (data.yOffsetFromBottom / this.referenceHeight) * gameHeight;
                const buildingHeight = (data.height / this.referenceHeight) * gameHeight;

                const buildingBody = this.buildings.create(data.x, yPos, null)
                    .setSize(data.width, buildingHeight)
                    .setOrigin(0.5, 0)
                    .setVisible(false) 
                    .refreshBody();
                
                buildingBody.buildingHealth = this.maxBuildingHealth;
                buildingBody.totalHealth = this.maxBuildingHealth; 
                buildingBody.visualX = data.x; 
                buildingBody.visualY = yPos + (buildingHeight * 0.5); 
                buildingBody.visualWidth = data.width; 
                buildingBody.visualHeight = buildingHeight; 
            });

            this.scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#fff', stroke: '#000', strokeThickness: 4 });
            this.healthBar = this.add.graphics();
            this.updateHealthBar(); 

            this.rockets = this.physics.add.group();
            this.physics.add.collider(this.rockets, this.buildings, this.hitBuilding, null, this);
            
            this.time.addEvent({ delay: 1500, callback: this.spawnRocket, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 1000, callback: this.increaseGameTime, callbackScope: this, loop: true });

            this.logoPart1 = this.add.image(0, 0, 'logo_part_1').setVisible(false);
            this.logoPart2 = this.add.image(0, 0, 'logo_part_2').setVisible(false);
            this.logoPart3 = this.add.image(0, 0, 'logo_part_3').setVisible(false);
            this.logoPart4 = this.add.image(0, 0, 'logo_part_4').setVisible(false);
            this.fullLogo = this.add.image(gameWidth / 2, gameHeight / 2, 'full_logo').setVisible(false);
        }

        updateHealthBar() {
            this.healthBar.clear();
            const gameWidth = this.cameras.main.width;
            const scoreTextBounds = this.scoreText.getBounds(); 

            const healthBarWidth = 200;
            const healthBarHeight = 30;
            const healthBarX = 16; 
            const healthBarY = scoreTextBounds.bottom + 10; 

            let totalCurrentHealth = 0;
            this.buildings.children.each(b => {
                if (b.body.enable) { 
                     totalCurrentHealth += b.buildingHealth;
                }
            });
            const totalMaxHealth = this.totalBuildings * this.maxBuildingHealth;
            const healthRatio = totalMaxHealth > 0 ? totalCurrentHealth / totalMaxHealth : 0; 

            this.healthBar.fillStyle(0x000000, 0.7); 
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            this.healthBar.fillStyle(0x00FF00); 
            if (healthRatio < 0.5) {
                this.healthBar.fillStyle(0xFFFF00); 
            }
            if (healthRatio < 0.25) {
                this.healthBar.fillStyle(0xFF0000); 
            }
            this.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth * healthRatio, healthBarHeight);

            this.healthBar.lineStyle(2, 0xFFFFFF); 
            this.healthBar.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        }

        increaseGameTime() {
            this.gameTime++;
        }

        spawnRocket() {
            if (this.gameIsOver) return;

            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;

            let startX, startY, velocityX, velocityY, angle;
            let spawnType = Phaser.Math.Between(0, 100); 

            let baseSpeed = 150 + (this.gameTime * 2);
            let maxSpeed = 400 + (this.gameTime * 5);
            if (baseSpeed > 600) baseSpeed = 600;
            if (maxSpeed > 800) maxSpeed = 800;

            let buildingDamageBonus = this.buildingsDestroyed * 50; 
            baseSpeed += buildingDamageBonus;
            maxSpeed += buildingDamageBonus;

            const activeBuildings = this.buildings.children.entries.filter(b => b.body.enable);
            let targetBuilding = null;
            if (activeBuildings.length > 0) {
                targetBuilding = Phaser.Utils.Array.GetRandom(activeBuildings);
            }
            
            let targetX, targetY;
            if (targetBuilding) {
                targetX = targetBuilding.x + Phaser.Math.Between(-targetBuilding.body.width / 4, targetBuilding.body.width / 4);
                targetY = targetBuilding.y + Phaser.Math.Between(0, targetBuilding.body.height / 3); 
            } else {
                targetX = gameWidth / 2;
                targetY = gameHeight * 0.8;
            }

            if (this.gameTime < 10 || spawnType < 70) {
                startX = Phaser.Math.Between(40, gameWidth - 40);
                startY = -100;
                
                const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                velocityX = Math.cos(angleToTarget) * speed;
                velocityY = Math.sin(angleToTarget) * speed;
                angle = Phaser.Math.RadToDeg(angleToTarget) + 90; 
            } else {
                let side = Phaser.Math.Between(0, 1) === 0 ? 'left' : 'right';

                if (side === 'left') {
                    startX = -100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7); 
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                } else { 
                    startX = gameWidth + 100;
                    startY = Phaser.Math.Between(gameHeight * 0.3, gameHeight * 0.7);
                    
                    const angleToTarget = Phaser.Math.Angle.Between(startX, startY, targetX, targetY);
                    const speed = Phaser.Math.Between(baseSpeed, maxSpeed);
                    velocityX = Math.cos(angleToTarget) * speed;
                    velocityY = Math.sin(angleToTarget) * speed;
                    angle = Phaser.Math.RadToDeg(angleToTarget) + 90;
                }
            }

            const rocket = this.rockets.create(startX, startY, "rocket");
            rocket.setAngle(angle);
            rocket.setVelocity(velocityX, velocityY);
            rocket.setInteractive({ useHandCursor: true });
            rocket.on("pointerdown", () => this.destroyRocket(rocket));

            rocket.setCollideWorldBounds(false);
            rocket.body.onWorldBounds = true;
            this.physics.world.on('worldbounds', (body) => {
                if (body.gameObject === rocket && !this.gameIsOver) {
                    rocket.destroy();
                }
            }, this);
        }

        destroyRocket(rocket) {
            if (!rocket.active || this.gameIsOver) return;

            this.score += 10;
            this.scoreText.setText("Score: " + this.score);

            const explosion = this.add.image(rocket.x, rocket.y, "explosion").setScale(1.5); 
            this.time.delayedCall(150, () => explosion.destroy());

            const dove = this.add.image(rocket.x, rocket.y, 'dove').setScale(0.4); 
            this.tweens.add({
                targets: dove,
                y: dove.y - 100, 
                alpha: 0, 
                duration: 1000,
                ease: 'Power1',
                onComplete: () => {
                    dove.destroy();
                }
            });

            rocket.destroy();
        }

        hitBuilding(rocket, building) {
            if (!rocket.active || !building.body.enable || this.gameIsOver) return;

            building.buildingHealth--; 
            
            window.Telegram && window.Telegram.WebApp.HapticFeedback.notificationOccurred("error");

            const explosion = this.add.image(rocket.x, rocket.y + 20, "explosion").setScale(1.2).setTint(0xFF0000);
            this.time.delayedCall(300, () => explosion.destroy());
            this.cameras.main.shake(200, 0.02);

            rocket.destroy(); 

            if (building.buildingHealth <= 0) {
                this.buildingsDestroyed++;
                building.body.enable = false; 
                building.setVisible(false); 

                const destroyedSprite = this.add.image(building.visualX, building.visualY, 'destroyed_building');
                destroyedSprite.setOrigin(0.5, 0.5); 
                
                const originalScaleFactor = Math.min(building.visualWidth / destroyedSprite.width, building.visualHeight / destroyedSprite.height);
                const newScaleFactor = originalScaleFactor * 2.0; 
                destroyedSprite.setScale(newScaleFactor); 
                this.destroyedBuildingSprites.add(destroyedSprite);

                const finalExplosion = this.add.image(building.visualX, building.visualY, "explosion").setScale(2).setTint(0x800000);
                this.time.delayedCall(500, () => finalExplosion.destroy());
            }

            this.updateHealthBar(); 

            if (this.buildingsDestroyed >= this.totalBuildings) {
                this.saveGameScore(this.score, (isNewHighScore) => { 
                    this.gameOver(isNewHighScore);
                });
            }
        }

        gameOver(isNewHighScore = false) {
            if (this.gameIsOver) return;
            this.gameIsOver = true;
            this.physics.pause();
            window.Telegram && window.Telegram.WebApp.HapticFeedback.notificationOccurred("success"); 

            this.rockets.children.each(rocket => rocket.destroy());
            
            const gameWidth = this.cameras.main.width;
            const gameHeight = this.cameras.main.height;
            const centerX = gameWidth / 2;
            const centerY = gameHeight / 2;

            this.add.rectangle(centerX, centerY, gameWidth, gameHeight, 0x000000, 0.1);
            
            if (isNewHighScore) {
                const logoStartScale = 0.4; 
                const logoTargetScale = 0.8; 
                const fullLogoScale = 0.9; 

                const tweenDuration = 2500; 
                const ease = 'Power2';

                const newHighScoreTextStyle = {
                    fontSize: "36px", 
                    fill: "#FFD700", 
                    align: "center",
                    stroke: '#000', 
                    strokeThickness: 6
                };

                const startOffset = Math.max(gameWidth, gameHeight); 

                this.logoPart1.setPosition(centerX - startOffset, centerY - startOffset).setVisible(true).setScale(logoStartScale);
                this.logoPart2.setPosition(centerX + startOffset, centerY - startOffset).setVisible(true).setScale(logoStartScale);
                this.logoPart3.setPosition(centerX - startOffset, centerY + startOffset).setVisible(true).setScale(logoStartScale);
                this.logoPart4.setPosition(centerX + startOffset, centerY + startOffset).setVisible(true).setScale(logoStartScale);

                const offsetFactorX = gameWidth * 0.1; 
                const offsetFactorY = gameHeight * 0.07; 

                this.tweens.add({ targets: this.logoPart1, x: centerX - offsetFactorX, y: centerY - offsetFactorY, scale: logoTargetScale, duration: tweenDuration, ease: ease }); 
                this.tweens.add({ targets: this.logoPart2, x: centerX + offsetFactorX, y: centerY - offsetFactorY, scale: logoTargetScale, duration: tweenDuration, ease: ease }); 
                this.tweens.add({ targets: this.logoPart3, x: centerX - offsetFactorX, y: centerY + offsetFactorY, scale: logoTargetScale, duration: tweenDuration, ease: ease }); 
                this.tweens.add({
                    targets: this.logoPart4,
                    x: centerX + offsetFactorX,
                    y: centerY + offsetFactorY,
                    scale: logoTargetScale, 
                    duration: tweenDuration,
                    ease: ease,
                    onComplete: () => {
                        this.logoPart1.setVisible(false);
                        this.logoPart2.setVisible(false);
                        this.logoPart3.setVisible(false);
                        this.logoPart4.setVisible(false);
                        this.fullLogo.setVisible(true).setPosition(centerX, centerY).setScale(fullLogoScale); 

                        this.add.text(centerX, centerY + (this.textures.get('full_logo').getSourceImage().height * fullLogoScale) / 2 + 50, "New Score!\n: " + this.score, newHighScoreTextStyle).setOrigin(0.5); 
                        
                        this.time.delayedCall(4000, () => this.scene.start('LobbyScene')); 
                    }
                });
            } else {
                this.add.text(centerX, centerY, "Game Over\nScore: " + this.score, { fontSize: "48px", fill: "#ff0000", align: "center" }).setOrigin(0.5);
                this.time.delayedCall(4000, () => this.scene.start('LobbyScene')); 
            }
        }

        async saveGameScore(score, callback) {
            if (!db || !currentUser || !currentUser.id) {
                console.warn("Firebase veya kullanıcı bilgisi mevcut değil, skor kaydedilemiyor.");
                if (callback) callback(false);
                return;
            }

            const userDocRef = db.collection('users').doc(String(currentUser.id));

            try {
                const doc = await userDocRef.get();
                let currentHighScore = 0;
                let totalCoins = 0;
                let username = currentUser.username || currentUser.first_name || `User${currentUser.id}`;

                if (doc.exists) {
                    const data = doc.data();
                    currentHighScore = data.score || 0;
                    totalCoins = data.total_pmno_coins || 0;
                }

                let isNewHighScore = false;
                let updateData = {
                    total_score: firebase.firestore.FieldValue.increment(score) 
                };

                if (score > currentHighScore) {
                    isNewHighScore = true;
                    updateData.score = score; 
                    updateData.total_pmno_coins = firebase.firestore.FieldValue.increment(score + (100 * score)); 
                } else {
                    updateData.total_pmno_coins = firebase.firestore.FieldValue.increment(score); 
                }

                updateData.username = username;
                updateData.user_id = currentUser.id;

                await userDocRef.set(updateData, { merge: true });
                console.log("Skor ve coinler Firebase'e kaydedildi/güncellendi.");
                sendScoreToBot(currentUser.id, score); 
                if (callback) callback(isNewHighScore);

            } catch (error) {
                console.error("Skor kaydetme hatası:", error);
                if (callback) callback(false);
            }
        }
    }

    function sendScoreToBot(userId, score) {
        if (tg && tg.sendData) {
            const data = {
                type: 'score_update',
                user_id: userId,
                score: score
            };
            tg.sendData(JSON.stringify(data));
            console.log("Score sent to Telegram bot:", data);
        } else {
            console.warn("Telegram WebApp sendData mevcut değil.");
        }
    }

    const config = { 
        type: Phaser.AUTO, 
        width: window.innerWidth, 
        height: window.innerHeight, 
        physics: { 
            default: 'arcade', 
            arcade: { 
                gravity: { y: 0 } 
            } 
        }, 
        scene: [Preloader, LobbyScene, GameScene] 
    };

    function startGame() {
        try { 
            const game = new Phaser.Game(config); 
            console.log("Phaser oyunu başlatıldı.");
        } catch (e) { 
            document.body.innerHTML = `<h1 style="color:red;">HATA: ${e.message}</h1>`; 
            console.error("Oyun başlatılırken kritik hata:", e);
        }
    }

    window.addEventListener('load', startGame);

</script>
</body>
</html>